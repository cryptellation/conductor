// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/lerenn/conductor/pkg/adapters/dagger (interfaces: Dagger)
//
// Generated by this command:
//
//	mockgen -destination=mock_dagger.gen.go -package=dagger . Dagger
//

// Package dagger is a generated GoMock package.
package dagger

import (
	context "context"
	reflect "reflect"

	dagger "dagger.io/dagger"
	gomock "go.uber.org/mock/gomock"
)

// MockDagger is a mock of Dagger interface.
type MockDagger struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerMockRecorder
	isgomock struct{}
}

// MockDaggerMockRecorder is the mock recorder for MockDagger.
type MockDaggerMockRecorder struct {
	mock *MockDagger
}

// NewMockDagger creates a new mock instance.
func NewMockDagger(ctrl *gomock.Controller) *MockDagger {
	mock := &MockDagger{ctrl: ctrl}
	mock.recorder = &MockDaggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDagger) EXPECT() *MockDaggerMockRecorder {
	return m.recorder
}

// CloneRepo mocks base method.
func (m *MockDagger) CloneRepo(ctx context.Context, repoURL, branch string) (*dagger.Directory, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloneRepo", ctx, repoURL, branch)
	ret0, _ := ret[0].(*dagger.Directory)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CloneRepo indicates an expected call of CloneRepo.
func (mr *MockDaggerMockRecorder) CloneRepo(ctx, repoURL, branch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloneRepo", reflect.TypeOf((*MockDagger)(nil).CloneRepo), ctx, repoURL, branch)
}

// Close mocks base method.
func (m *MockDagger) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockDaggerMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockDagger)(nil).Close))
}

// CommitAndPush mocks base method.
func (m *MockDagger) CommitAndPush(ctx context.Context, dir *dagger.Directory, modulePath, targetVersion, authorName, authorEmail, repoURL string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitAndPush", ctx, dir, modulePath, targetVersion, authorName, authorEmail, repoURL)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitAndPush indicates an expected call of CommitAndPush.
func (mr *MockDaggerMockRecorder) CommitAndPush(ctx, dir, modulePath, targetVersion, authorName, authorEmail, repoURL any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitAndPush", reflect.TypeOf((*MockDagger)(nil).CommitAndPush), ctx, dir, modulePath, targetVersion, authorName, authorEmail, repoURL)
}

// UpdateGoDependency mocks base method.
func (m *MockDagger) UpdateGoDependency(ctx context.Context, dir *dagger.Directory, modulePath, targetVersion string) (*dagger.Directory, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateGoDependency", ctx, dir, modulePath, targetVersion)
	ret0, _ := ret[0].(*dagger.Directory)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateGoDependency indicates an expected call of UpdateGoDependency.
func (mr *MockDaggerMockRecorder) UpdateGoDependency(ctx, dir, modulePath, targetVersion any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateGoDependency", reflect.TypeOf((*MockDagger)(nil).UpdateGoDependency), ctx, dir, modulePath, targetVersion)
}
