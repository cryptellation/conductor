//go:generate go run go.uber.org/mock/mockgen@v0.5.2 -source=client.go -destination=mock.gen.go -package=github
package github

import (
	"context"
	"fmt"
	"strings"

	"github.com/google/go-github/v55/github"
	"golang.org/x/oauth2"
)

// GetFileContentParams contains parameters for GetFileContent.
type GetFileContentParams struct {
	Owner string
	Repo  string
	Path  string
	Ref   string
}

// CreateMergeRequestParams contains parameters for CreateMergeRequest.
type CreateMergeRequestParams struct {
	RepoURL       string
	SourceBranch  string
	ModulePath    string
	TargetVersion string
}

// CheckPullRequestExistsParams contains parameters for CheckPullRequestExists.
type CheckPullRequestExistsParams struct {
	RepoURL      string
	SourceBranch string
}

// Client defines the interface for interacting with GitHub.
type Client interface {
	GetFileContent(ctx context.Context, params GetFileContentParams) ([]byte, error)
	ListTags(ctx context.Context, owner, repo string) ([]*github.RepositoryTag, error)
	CreateMergeRequest(ctx context.Context, params CreateMergeRequestParams) error
	CheckPullRequestExists(ctx context.Context, params CheckPullRequestExistsParams) (int, error)
}

// client implements Client using go-github.
type client struct {
	gh *github.Client
}

// New creates a new GitHub client with the given token.
func New(token string) Client {
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
	gh := github.NewClient(oauth2.NewClient(context.Background(), ts))
	return &client{gh: gh}
}

// GetFileContent retrieves the content of a file from a GitHub repository.
func (c *client) GetFileContent(ctx context.Context, params GetFileContentParams) ([]byte, error) {
	fileContent, _, _, err := c.gh.Repositories.GetContents(
		ctx, params.Owner, params.Repo, params.Path,
		&github.RepositoryContentGetOptions{Ref: params.Ref},
	)
	if err != nil {
		return nil, err
	}
	if fileContent == nil {
		return nil, nil
	}
	content, err := fileContent.GetContent()
	if err != nil {
		return nil, err
	}
	return []byte(content), nil
}

// ListTags retrieves the tags of a GitHub repository.
func (c *client) ListTags(ctx context.Context, owner, repo string) ([]*github.RepositoryTag, error) {
	tags, _, err := c.gh.Repositories.ListTags(ctx, owner, repo, nil)
	return tags, err
}

// CreateMergeRequest creates a merge request in the specified repository.
func (c *client) CreateMergeRequest(ctx context.Context, params CreateMergeRequestParams) error {
	// Extract owner and repo from the repository URL
	// Format: https://github.com/owner/repo
	parts := strings.Split(strings.TrimPrefix(params.RepoURL, "https://"), "/")
	if len(parts) != 3 {
		return fmt.Errorf("invalid repository URL format: %s", params.RepoURL)
	}
	owner := parts[1]
	repo := parts[2]

	// Generate MR title and description
	title := generateMRTitle(params.ModulePath, params.TargetVersion)
	description := generateMRDescription(params.ModulePath, params.TargetVersion)

	// Create the pull request
	pr := &github.NewPullRequest{
		Title: &title,
		Body:  &description,
		Head:  &params.SourceBranch,
		Base:  github.String("main"), // Using constant as specified
	}

	_, _, err := c.gh.PullRequests.Create(ctx, owner, repo, pr)
	return err
}

// CheckPullRequestExists checks if a pull request already exists for the given branch.
// Returns the PR number if it exists, or -1 if it doesn't exist.
func (c *client) CheckPullRequestExists(ctx context.Context, params CheckPullRequestExistsParams) (int, error) {
	// Extract owner and repo from the repository URL
	// Format: https://github.com/owner/repo
	parts := strings.Split(strings.TrimPrefix(params.RepoURL, "https://"), "/")
	if len(parts) != 3 {
		return -1, fmt.Errorf("invalid repository URL format: %s", params.RepoURL)
	}
	owner := parts[1]
	repo := parts[2]

	// List pull requests with the specific head branch
	opts := &github.PullRequestListOptions{
		Head:  fmt.Sprintf("%s:%s", owner, params.SourceBranch),
		State: "open",
	}

	pulls, _, err := c.gh.PullRequests.List(ctx, owner, repo, opts)
	if err != nil {
		return -1, err
	}

	// If any pull requests are returned, return the first one's number
	if len(pulls) > 0 {
		return *pulls[0].Number, nil
	}

	// No pull request found
	return -1, nil
}

// generateMRTitle generates the title for a merge request.
func generateMRTitle(modulePath, targetVersion string) string {
	// Extract the last part of the module path for a cleaner title
	parts := strings.Split(modulePath, "/")
	dependencyName := parts[len(parts)-1]
	return fmt.Sprintf("[Conductor] Update %s to %s", dependencyName, targetVersion)
}

// generateMRDescription generates the description for a merge request.
func generateMRDescription(modulePath, targetVersion string) string {
	return fmt.Sprintf(`## Dependency Update

This merge request updates the dependency **%s** to version **%s**.

### Changes
- Updated dependency: `+"`%s`"+`
- New version: `+"`%s`"+`

This update was automatically generated by Conductor.`, modulePath, targetVersion, modulePath, targetVersion)
}
