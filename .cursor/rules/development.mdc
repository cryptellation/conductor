
# Environment Variable and GitHub CLI Usage Rule

## .env Loading for Tests
- Before running any tests (locally or in CI), always ensure that environment variables from a `.env` file (but not example env files) are loaded into the environment.
- Use a tool like `direnv`, `dotenv`, or a shell command to source the `.env` file before test execution.
- If a test requires a specific variable (e.g., `GITHUB_TOKEN`), document this in the test or README.
- Example (shell):
  ```sh
  export $(grep -v '^#' example.env | xargs) && go test ./...
  ```
- Tests that depend on environment variables must skip gracefully if the required variable is not set (see integration test pattern in `internal/adapters/github/client_test.go`).

## GitHub CLI (gh) Usage
- When using the GitHub CLI (`gh`), ensure that the `GITHUB_TOKEN` environment variable is **not** set in the environment.
- If `GITHUB_TOKEN` is set, prefer using the Go client or API directly for authentication.
- Only use `gh` for operations that do not require a `GITHUB_TOKEN`, or after unsetting it:
  ```sh
  unset GITHUB_TOKEN && gh <command>
  ```
- Document in scripts or README when and why `gh` is used instead of the Go client or direct API calls.

---

# Development Plan & Feature Branch Workflow Rule

When the AI is asked to perform a task from the development plan (e.g., in `docs/development_plan.md`) or to implement a new feature:

1. **Status Update**: Cursor must update the status line for the relevant subtask to `in progress` at the start of the process.
2. **Development**: All work for the feature or subtask should be done on the current branch until ready to commit.
3. **Branch Creation (Before Commit)**: Just before committing the changes for a new feature or subtask, Cursor must:
    - Create a new git branch. The branch name should be descriptive of the feature or task. Branch prefix should be "BREAKING-CHANGE-", "feat-", or "fix-".
    - Set the status in the development plan to `done` right before committing the code.
    - Check for any non-added (unstaged/untracked) code in Git. Cursor must confirm that any such code is irrelevant to the current changes. If it is relevant, it must be added before committing to avoid forgetting code.
4. **Committing**: All work for the feature or subtask must be committed to the new branch.
5. **Completion & Review**:
    - When the implementation is complete, Cursor must prompt the user for review.
    - The status must remain `done` until the user has reviewed the feature and confirmed that all tests are green.
6. **Final Status**: Only after user approval, run the dagger functions based on `.github/workflows/ci.yaml`.
7. **Pushing & Pull Request**: After user approval and confirmation that all tests pass, Cursor must push the new branch to GitHub, create a pull request, and:
    - Wait for all required checks to pass and merge the PR automatically once all checks are successful, **or**
    - If there are no checks, merge the PR immediately.
8. **Go back on main and update**: Once the user indicates that the PR has been merged or Cursor merged it successfully, Cursor must go back to main and git pull.

## Statuses
- `to do`: Not started
- `in progress`: Task is being worked on
- `done`: Task is completed, reviewed, and approved by a human. **This status must be set right before committing the code, after confirming all relevant changes are staged.**

## Example

Before:
```markdown
- 1.1.1 Specify how repositories, services, and libraries are listed in a YAML configuration file.
  - Status:
```

After starting work:
```markdown
- 1.1.1 Specify how repositories, services, and libraries are listed in a YAML configuration file.
  - Status: in progress
```

Right before committing the code (after confirming all relevant changes are staged):
```markdown
- 1.1.1 Specify how repositories, services, and libraries are listed in a YAML configuration file.
  - Status: done
```

---

## Branch Workflow Example

1. User requests: "Implement feature X."
2. Cursor sets the status to `in progress` in the development plan
3. Cursor implements the feature on the current branch
4. Just before committing, Cursor:
    - Creates a branch: `feat/x-implementation` (or with the appropriate prefix: "BREAKING-CHANGE-", "feat-", or "fix-" and optional scope in brackets, e.g., `fix(cmd)-x-implementation`)
    - Sets the status to `done` in the development plan
    - Checks for any non-added code and confirms it is irrelevant, or adds it if relevant
5. Cursor commits all changes to the new branch using commit messages with the required prefix and optional scope (e.g., `feat(cmd): add X implementation`)
6. Cursor prompts the user for review and test confirmation
7. After user approval and confirmation that all tests pass, Cursor pushes the new branch to GitHub
8. Cursor creates a pull request, waits for all required checks to pass and merges the PR automatically, or merges immediately if there are no checks
9. Once the PR is merged, Cursor switches back to main and pulls the latest changes
